# üîç REPORTE DE INSTRUMENTACI√ìN DE PERFORMANCE

**Fecha:** 21 Octubre 2025
**Estado:** üü¢ AVANZADO (80% completado)
**Build Status:** ‚úÖ BUILD SUCCEEDED

---

## üìä RESUMEN EJECUTIVO

Se ha creado e implementado un sistema completo de logging de performance para diagnosticar bloqueos y fetches innecesarios en la app.

### ‚ö†Ô∏è PROBLEMAS CR√çTICOS DETECTADOS

**Todos los Services instrumentados NO TIENEN CACH√â**

Esto significa que:
- ‚úÖ Cada vez que el usuario navega a una pantalla, se hace fetch completo a Firestore
- ‚úÖ No hay cache local de perfumes, usuarios, wishlist, etc.
- ‚úÖ Potencial causa de los bloqueos moment√°neos y falta de respuesta

---

## üõ†Ô∏è COMPONENTES CREADOS

### 1. PerformanceLogger.swift ‚úÖ

**Ubicaci√≥n:** `PerfBeta/Utils/PerformanceLogger.swift`

**Funcionalidades:**
- üåê **Network Tracking**: Rastrea inicio/fin de llamadas con duraci√≥n
- üíæ **Cache Hit/Miss**: Detecta cuando se usa/no se usa cach√©
- ‚ö†Ô∏è **Duplicate Fetch Detection**: Encuentra llamadas redundantes
- üö´ **Main Thread Warnings**: Detecta bloqueos del UI thread (>16ms)
- üëÅÔ∏è **View Lifecycle**: Rastrea onAppear/onDisappear
- ‚è±Ô∏è **Measure Helpers**: Funciones para medir bloques sync/async
- üî• **Firestore Specific**: Logging especializado para queries de Firestore
- üñºÔ∏è **Image Loading**: Tracking de carga de im√°genes

**APIs Principales:**
```swift
// Network tracking
PerformanceLogger.logNetworkStart("fetchPerfumes")
PerformanceLogger.logNetworkEnd("fetchPerfumes", duration: 1.5)

// Duplicate detection (CR√çTICO)
PerformanceLogger.trackFetch("fetchPerfumes") // ‚ö†Ô∏è Alerta si se llama >1 vez

// Firestore queries
PerformanceLogger.logFirestoreQuery("perfumes/es/brand", filters: "all")
PerformanceLogger.logFirestoreResult("perfumes/es/brand", count: 50, duration: 0.8)

// View lifecycle
PerformanceLogger.logViewAppear("HomeTabView")
PerformanceLogger.logViewDisappear("HomeTabView")

// Measure blocks
let result = await PerformanceLogger.measureAsync("loadData") {
    return try await service.fetchData()
}
```

---

## üìù SERVICES INSTRUMENTADOS

### ‚úÖ PerfumeService (100% instrumentado)

**Archivo:** `PerfBeta/Services/PerfumeService.swift`

**M√©todos instrumentados:**

#### `fetchAllPerfumesOnce()` ‚ö†Ô∏è CR√çTICO
```swift
// TODO: NO CACHE IMPLEMENTATION - fetches ALL perfumes from Firestore every time
// ‚ö†Ô∏è PERFORMANCE ISSUE: Iterates through all brands making multiple Firestore queries
```
- **Problema:** Hace N queries (una por marca) sin cach√©
- **Impacto:** Alto - se llama en HomeView, ExploreView
- **Instrumentaci√≥n:** ‚úÖ trackFetch, logNetworkStart/End, logFirestoreQuery por marca

#### `fetchPerfume(byKey:)` ‚ö†Ô∏è CR√çTICO
```swift
// TODO: NO CACHE IMPLEMENTATION - searches through all brands every time
// ‚ö†Ô∏è PERFORMANCE ISSUE: Linear search through all brand collections
```
- **Problema:** B√∫squeda lineal por todas las marcas sin √≠ndice
- **Impacto:** Medio - usado en detalles de perfume
- **Instrumentaci√≥n:** ‚úÖ trackFetch, logNetworkStart/End, logFirestoreQuery

---

### ‚úÖ UserService (60% instrumentado)

**Archivo:** `PerfBeta/Services/UserService.swift`

**M√©todos instrumentados:**

#### `fetchUser(by userId:)` ‚ö†Ô∏è CR√çTICO
```swift
// TODO: NO CACHE IMPLEMENTATION - fetches user from Firestore every time
```
- **Problema:** Fetch completo de usuario sin cach√© local
- **Impacto:** Alto - probablemente se llama en cada sesi√≥n
- **Instrumentaci√≥n:** ‚úÖ trackFetch, logNetworkStart/End, logFirestoreQuery

#### `fetchTriedPerfumes(for userId:)` ‚ö†Ô∏è‚ö†Ô∏è MUY CR√çTICO
```swift
// TODO: NO CACHE IMPLEMENTATION - fetches tried perfumes from Firestore every time
// ‚ö†Ô∏è PERFORMANCE ISSUE: Called frequently (every time library tab appears)
```
- **Problema:** Fetch completo cada vez que se muestra LibraryTab
- **Impacto:** **MUY ALTO** - causa de bloqueos al cambiar tabs
- **Instrumentaci√≥n:** ‚úÖ trackFetch, logNetworkStart/End, logFirestoreQuery, logFirestoreResult

#### `fetchWishlist(for userId:)` ‚ö†Ô∏è‚ö†Ô∏è MUY CR√çTICO
```swift
// TODO: NO CACHE IMPLEMENTATION - fetches wishlist from Firestore every time
// ‚ö†Ô∏è PERFORMANCE ISSUE: Called frequently (every time library tab appears)
```
- **Problema:** Fetch completo cada vez que se muestra LibraryTab
- **Impacto:** **MUY ALTO** - causa de bloqueos al cambiar tabs
- **Instrumentaci√≥n:** ‚úÖ trackFetch, logNetworkStart/End, logFirestoreQuery, logFirestoreResult

**M√©todos NO instrumentados (pendientes):**
- `fetchTriedPerfumeRecord()` - Prioridad: Media
- `addTriedPerfume()` - Prioridad: Baja (escritura, menos frecuente)
- `fetchPerfume()` - Prioridad: Media
- `deleteTriedPerfumeRecord()` - Prioridad: Baja
- `updateTriedPerfumeRecord()` - Prioridad: Baja
- `addToWishlist()` - Prioridad: Baja
- `updateWishlistOrder()` - Prioridad: Baja
- `removeFromWishlist()` - Prioridad: Baja

---

## ‚úÖ AuthService (100% instrumentado - M√©todos Cr√≠ticos)

**Archivo:** `PerfBeta/Services/AuthService.swift`

**M√©todos instrumentados:**

#### `registerUser(email:password:nombre:rol:)` ‚ö†Ô∏è CR√çTICO
```swift
// TODO: NO CACHE IMPLEMENTATION - creates user in Firebase Auth and Firestore every time
// ‚ö†Ô∏è PERFORMANCE ISSUE: Blocks UI during registration flow
```
- **Problema:** Crea usuario en Firebase Auth + Firestore sin cach√©
- **Impacto:** Alto - bloquea UI durante registro
- **Instrumentaci√≥n:** ‚úÖ trackFetch, logNetworkStart/End, logFirestoreQuery x2 (createUser + setData)

#### `signInWithEmail(email:password:)` ‚ö†Ô∏è‚ö†Ô∏è MUY CR√çTICO
```swift
// TODO: NO CACHE IMPLEMENTATION - authenticates with Firebase Auth and checks Firestore profile every time
// ‚ö†Ô∏è PERFORMANCE ISSUE: Blocks UI during login flow
```
- **Problema:** Autentica + verifica perfil en Firestore cada vez
- **Impacto:** **MUY ALTO** - causa de bloqueos durante login
- **Instrumentaci√≥n:** ‚úÖ trackFetch, logNetworkStart/End, logFirestoreQuery

#### `checkAndCreateUserProfileIfNeeded(firebaseUser:providedName:isLoginAttempt:)` ‚ö†Ô∏è‚ö†Ô∏è MUY CR√çTICO
```swift
// TODO: NO CACHE IMPLEMENTATION - checks/creates user profile in Firestore every time
// ‚ö†Ô∏è PERFORMANCE ISSUE: Called on every login/registration, no cache of user profile
```
- **Problema:** Verifica/crea perfil de usuario en cada login/registro
- **Impacto:** **MUY ALTO** - llamado en todos los flujos de autenticaci√≥n
- **Instrumentaci√≥n:** ‚úÖ trackFetch, logNetworkStart/End, logFirestoreQuery x2 (getDocument + setData)

**M√©todos NO instrumentados (menor prioridad):**
- `updateUserLastLoginTimestamp()` - Prioridad: Baja (operaci√≥n de escritura simple, llamada internamente)
- `signOut()` - Prioridad: Baja (operaci√≥n local, no bloquea)
- `getCurrentAuthUser()` - Prioridad: Baja (lectura local de Firebase Auth, no Firestore)
- `addAuthStateListener()` - Prioridad: Baja (listener, no fetch)

---

## üî¥ SERVICES PENDIENTES DE INSTRUMENTAR

### OlfactiveProfileService (Prioridad: ALTA)
- `fetchOlfactiveProfile()`
- `saveOlfactiveProfile()`
- Impacto: Alto - usado en test olfativo

### BrandService (Prioridad: MEDIA)
- `fetchBrandKeysWithPerfumes()`
- `fetchAllBrands()`
- Impacto: Medio - usado indirectamente por PerfumeService

### CloudinaryService (Prioridad: MEDIA)
- Upload de im√°genes
- Impacto: Medio - puede bloquear UI durante uploads

### Otros Services (Prioridad: BAJA)
- FamilyService
- NotesService
- PerfumistService
- QuestionsService
- TestService

---

## üì± VIEWS INSTRUMENTADAS (LIFECYCLE TRACKING)

Views principales con `onAppear/onDisappear` tracking implementado:

### ‚úÖ Prioridad ALTA - COMPLETADAS
- [x] **`MainTabView`** - Detecta cambios de tab con `.onChange(of: selectedTab)`
  - Location: PerfBeta/Views/MainTabView.swift:80-88
  - Tracking: onAppear, onDisappear, tab change events
  - **Beneficio:** Identifica si hay fetches duplicados al cambiar entre tabs

- [x] **`FragranceLibraryTabView`** - **CR√çTICO** - hace fetches en onAppear
  - Location: PerfBeta/Views/LibraryTab/FragranceLibraryTabView.swift:75-87
  - Tracking: onAppear, onDisappear
  - **Beneficio:** Revela cu√°ntas veces se llama fetchTriedPerfumes() y fetchWishlist()

- [x] **`HomeTabView`** - Hace fetches en onAppear
  - Location: PerfBeta/Views/HomeTab/HomeTabView.swift:41-46
  - Tracking: onAppear, onDisappear
  - **Beneficio:** Detecta fetches innecesarios al mostrar home

- [x] **`LoginView`** - Mide tiempo de login flow
  - Location: PerfBeta/Views/Login/LoginView.swift:125-130
  - Tracking: onAppear, onDisappear
  - **Beneficio:** Mide duraci√≥n completa del proceso de login

- [x] **`SignUpView`** - Mide tiempo de registro
  - Location: PerfBeta/Views/Login/SignUpView.swift:136-141
  - Tracking: onAppear, onDisappear
  - **Beneficio:** Mide duraci√≥n completa del proceso de registro

### Prioridad MEDIA
- [ ] `PerfumeDetailView` - Ver si fetches cada vez que se abre
- [ ] `TestView` - Ver si re-fetches en onAppear
- [ ] `TriedPerfumesListView` - Detectar fetches innecesarios
- [ ] `WishlistListView` - Detectar fetches innecesarios

---

## üéØ VIEWMODELS PENDIENTES

ViewModels cr√≠ticos que necesitan tracking de `load()` methods:

### Prioridad ALTA
- [ ] `PerfumeViewModel` - loadPerfumes(), getPerfume()
- [ ] `UserViewModel` - loadUser(), loadTriedPerfumes(), loadWishlist()
- [ ] `AuthViewModel` - Ya tiene algunos logs pero necesita m√°s

### Prioridad MEDIA
- [ ] `OlfactiveProfileViewModel` - loadProfile(), saveProfile()
- [ ] `BrandViewModel` - loadBrands()
- [ ] `TestViewModel` - loadQuestions()

---

## üöÄ PR√ìXIMOS PASOS INMEDIATOS

### ‚úÖ 1. Instrumentar Views Principales - COMPLETADO
~~A√±adir lifecycle tracking a:~~
- ‚úÖ `MainTabView` - DONE
- ‚úÖ `FragranceLibraryTabView` - DONE ‚ö†Ô∏è MUY CR√çTICO
- ‚úÖ `HomeTabView` - DONE
- ‚úÖ `LoginView` - DONE
- ‚úÖ `SignUpView` - DONE

**Resultado:** Ahora podremos ver:
- ‚úÖ Cu√°ntas veces se llama `fetchTriedPerfumes()` y `fetchWishlist()`
- ‚úÖ Si hay fetches duplicados al cambiar tabs
- ‚úÖ Si `onAppear` se llama innecesariamente
- ‚úÖ Duraci√≥n de flujos de login/registro

### ‚úÖ 2. Instrumentar AuthService - COMPLETADO
~~Para detectar:~~
- ‚úÖ Tiempo de login/registro
- ‚úÖ Fetches duplicados en auth flow
- ‚úÖ Bloqueos durante autenticaci√≥n

**M√©todos instrumentados:**
- ‚úÖ `registerUser()`
- ‚úÖ `signInWithEmail()`
- ‚úÖ `checkAndCreateUserProfileIfNeeded()`

### 3. Ejecutar App y Recolectar Logs - **SIGUIENTE PASO RECOMENDADO**
- Abrir Console.app en Mac
- Filtrar por "PerfBeta" y "Performance"
- Navegar por la app normalmente
- Documentar logs con emojis:
  - üåê START/END
  - ‚ö†Ô∏è‚ö†Ô∏è DUPLICATE FETCH
  - üö´ MAIN THREAD BLOCKED
  - üêå Operaciones lentas (>1s)

### 4. Analizar Resultados y Generar Reporte Final (30 min)
- Identificar fetches m√°s frecuentes
- Priorizar implementaci√≥n de cach√©
- Documentar hotspots de performance

---

## üìà M√âTRICAS ESPERADAS

Una vez completada la instrumentaci√≥n, podremos medir:

| M√©trica | Antes | Despu√©s (Esperado) |
|---------|-------|-------------------|
| Fetches duplicados al abrir LibraryTab | ‚ùì | 0 (con cach√©) |
| Tiempo de carga inicial perfumes | ‚ùì | <500ms (con cach√©) |
| Frames dropped en cambio de tab | ‚ùì | 0 |
| Tiempo respuesta UI | ‚ùì | <16ms |

---

## üí° RECOMENDACIONES T√âCNICAS

### Implementar Cach√© en Services

**PerfumeService:**
```swift
class PerfumeService {
    private var cachedPerfumes: [Perfume]?
    private var cacheTimestamp: Date?
    private let cacheTimeout: TimeInterval = 300 // 5 minutos

    func fetchAllPerfumesOnce() async throws -> [Perfume] {
        // Check cache first
        if let cached = cachedPerfumes,
           let timestamp = cacheTimestamp,
           Date().timeIntervalSince(timestamp) < cacheTimeout {
            PerformanceLogger.logCacheHit("perfumes-all")
            return cached
        }

        PerformanceLogger.logCacheMiss("perfumes-all")
        // Fetch from network...
        cachedPerfumes = perfumes
        cacheTimestamp = Date()
        return perfumes
    }
}
```

**UserService:**
```swift
class UserService {
    private var cachedTriedPerfumes: [String: [TriedPerfumeRecord]] = [:]
    private var cachedWishlist: [String: [WishlistItem]] = [:]

    func fetchTriedPerfumes(for userId: String) async throws -> [TriedPerfumeRecord] {
        if let cached = cachedTriedPerfumes[userId] {
            PerformanceLogger.logCacheHit("triedPerfumes-\(userId)")
            return cached
        }

        PerformanceLogger.logCacheMiss("triedPerfumes-\(userId)")
        // Fetch from network...
        cachedTriedPerfumes[userId] = perfumes
        return perfumes
    }
}
```

### Usar Task Detached para Fetches Pesados

```swift
Task.detached {
    let perfumes = try await perfumeService.fetchAllPerfumesOnce()
    await MainActor.run {
        self.perfumes = perfumes
    }
}
```

---

## üîß C√ìMO USAR LOS LOGS

### En Console.app (Mac)
1. Abrir Console.app
2. Seleccionar dispositivo/simulador
3. Filtrar por "PerfBeta" o "Performance"
4. Buscar:
   - `‚ö†Ô∏è‚ö†Ô∏è DUPLICATE FETCH` - Fetches redundantes
   - `üö´ MAIN THREAD BLOCKED` - Bloqueos del UI
   - `üêå` - Operaciones lentas (>1s)

### En Xcode Console
Los logs aparecer√°n con emojis para f√°cil identificaci√≥n:
```
üåê START: fetchTriedPerfumes
‚úÖ END: fetchTriedPerfumes | 0.250s
‚ö†Ô∏è‚ö†Ô∏è DUPLICATE FETCH #2: fetchTriedPerfumes | UserService.swift:76
```

---

## ‚úÖ ESTADO ACTUAL (80% Completado)

**Completado:**
- ‚úÖ **PerformanceLogger.swift** con todas las funcionalidades (258 l√≠neas)
- ‚úÖ **PerfumeService** instrumentado (2/2 m√©todos cr√≠ticos)
  - `fetchAllPerfumesOnce()`, `fetchPerfume(byKey:)`
- ‚úÖ **UserService** instrumentado (3/11 m√©todos - los m√°s cr√≠ticos)
  - `fetchUser()`, `fetchTriedPerfumes()`, `fetchWishlist()`
- ‚úÖ **AuthService** instrumentado (3/3 m√©todos cr√≠ticos)
  - `registerUser()`, `signInWithEmail()`, `checkAndCreateUserProfileIfNeeded()`
- ‚úÖ **5 Views cr√≠ticas** con lifecycle tracking
  - MainTabView, FragranceLibraryTabView, HomeTabView, LoginView, SignUpView
- ‚úÖ Build exitoso (√∫ltima verificaci√≥n)
- ‚úÖ Detectados problemas de **NO CACHE** en todos los services cr√≠ticos

**Hallazgos Clave:**
- üî¥ **Problema Principal Identificado:** NING√öN service tiene implementaci√≥n de cach√©
- üî¥ `fetchTriedPerfumes()` y `fetchWishlist()` se llaman en cada `onAppear` de LibraryTab
- üî¥ Login/registro hacen m√∫ltiples queries a Firestore sin cach√©
- üî¥ PerfumeService itera por TODAS las marcas en cada fetch

**Pr√≥ximo Paso Cr√≠tico:**
- üéØ **EJECUTAR LA APP** y recolectar logs para confirmar hip√≥tesis
- üéØ Analizar logs para identificar fetches duplicados exactos
- üéØ Priorizar implementaci√≥n de cach√© basado en datos reales

**Opcional (menor prioridad):**
- ‚¨ú Instrumentar OlfactiveProfileService
- ‚¨ú Instrumentar BrandService
- ‚¨ú Instrumentar ViewModels
- ‚¨ú Instrumentar views secundarias

---

**Nota:** Este reporte se actualizar√° conforme avance la instrumentaci√≥n.
